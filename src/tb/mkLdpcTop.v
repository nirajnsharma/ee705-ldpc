//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Wed May  1 14:03:27 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// readdata                       O    32 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// req_addr                       I     2
// req_rd_cmd                     I     1
// req_wr_cmd                     I     1
// req_wdata                      I    32
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkLdpcTop(CLK,
		 RST_N,

		 req_addr,
		 req_rd_cmd,
		 req_wr_cmd,
		 req_wdata,

		 readdata);
  input  CLK;
  input  RST_N;

  // action method req
  input  [1 : 0] req_addr;
  input  req_rd_cmd;
  input  req_wr_cmd;
  input  [31 : 0] req_wdata;

  // value method readdata
  output [31 : 0] readdata;

  // signals for module outputs
  wire [31 : 0] readdata;

  // register rg_busy
  reg rg_busy;
  wire rg_busy$D_IN, rg_busy$EN;

  // register rg_cmpl
  reg rg_cmpl;
  wire rg_cmpl$D_IN, rg_cmpl$EN;

  // register rg_go
  reg rg_go;
  wire rg_go$D_IN, rg_go$EN;

  // register rg_op1
  reg [6 : 0] rg_op1;
  wire [6 : 0] rg_op1$D_IN;
  wire rg_op1$EN;

  // register rg_read_data
  reg [31 : 0] rg_read_data;
  reg [31 : 0] rg_read_data$D_IN;
  wire rg_read_data$EN;

  // register rg_result
  reg [6 : 0] rg_result;
  wire [6 : 0] rg_result$D_IN;
  wire rg_result$EN;

  // ports of submodule core
  wire [6 : 0] core$request_put, core$response_get;
  wire core$EN_request_put,
       core$EN_response_get,
       core$RDY_request_put,
       core$RDY_response_get;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_req_to_core,
       CAN_FIRE_RL_rl_rsp_from_core,
       CAN_FIRE_req,
       WILL_FIRE_RL_rl_req_to_core,
       WILL_FIRE_RL_rl_rsp_from_core,
       WILL_FIRE_req;

  // declarations used by system tasks
  // synopsys translate_off
  reg [31 : 0] v__h3128;
  reg [31 : 0] v__h2296;
  // synopsys translate_on

  // remaining internal signals
  wire [31 : 0] x__h2988, x__h2995, x__h3002;
  wire [1 : 0] x__h3109;

  // action method req
  assign CAN_FIRE_req = 1'd1 ;
  assign WILL_FIRE_req = 1'd1 ;

  // value method readdata
  assign readdata = rg_read_data ;

  // submodule core
  mkLdpcCore core(.CLK(CLK),
		  .RST_N(RST_N),
		  .request_put(core$request_put),
		  .EN_request_put(core$EN_request_put),
		  .EN_response_get(core$EN_response_get),
		  .RDY_request_put(core$RDY_request_put),
		  .response_get(core$response_get),
		  .RDY_response_get(core$RDY_response_get));

  // rule RL_rl_req_to_core
  assign CAN_FIRE_RL_rl_req_to_core =
	     core$RDY_request_put && !rg_busy && rg_go ;
  assign WILL_FIRE_RL_rl_req_to_core = CAN_FIRE_RL_rl_req_to_core ;

  // rule RL_rl_rsp_from_core
  assign CAN_FIRE_RL_rl_rsp_from_core = core$RDY_response_get ;
  assign WILL_FIRE_RL_rl_rsp_from_core = core$RDY_response_get ;

  // register rg_busy
  assign rg_busy$D_IN = !core$RDY_response_get ;
  assign rg_busy$EN = core$RDY_response_get || WILL_FIRE_RL_rl_req_to_core ;

  // register rg_cmpl
  assign rg_cmpl$D_IN = 1'b1 ;
  assign rg_cmpl$EN = core$RDY_response_get ;

  // register rg_go
  assign rg_go$D_IN = !core$RDY_response_get && req_wdata[0] ;
  assign rg_go$EN =
	     !req_rd_cmd && req_wr_cmd && req_addr == 2'b0 ||
	     core$RDY_response_get ;

  // register rg_op1
  assign rg_op1$D_IN = req_wdata[6:0] ;
  assign rg_op1$EN = !req_rd_cmd && req_wr_cmd && req_addr == 2'b01 ;

  // register rg_read_data
  always@(req_addr or x__h2988 or x__h2995 or x__h3002)
  begin
    case (req_addr)
      2'b0: rg_read_data$D_IN = x__h2988;
      2'b01: rg_read_data$D_IN = x__h2995;
      2'b10: rg_read_data$D_IN = x__h3002;
      2'd3: rg_read_data$D_IN = 32'b0;
    endcase
  end
  assign rg_read_data$EN = req_rd_cmd && !req_wr_cmd ;

  // register rg_result
  assign rg_result$D_IN = core$response_get ;
  assign rg_result$EN = core$RDY_response_get ;

  // submodule core
  assign core$request_put = rg_op1 ;
  assign core$EN_request_put = CAN_FIRE_RL_rl_req_to_core ;
  assign core$EN_response_get = core$RDY_response_get ;

  // remaining internal signals
  assign x__h2988 = { 30'd0, x__h3109 } ;
  assign x__h2995 = { 25'd0, rg_op1 } ;
  assign x__h3002 = { 25'd0, rg_result } ;
  assign x__h3109 = { rg_cmpl, rg_go } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_busy <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_cmpl <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_go <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_op1 <= `BSV_ASSIGNMENT_DELAY 7'd0;
	rg_read_data <= `BSV_ASSIGNMENT_DELAY 32'd0;
	rg_result <= `BSV_ASSIGNMENT_DELAY 7'd0;
      end
    else
      begin
        if (rg_busy$EN) rg_busy <= `BSV_ASSIGNMENT_DELAY rg_busy$D_IN;
	if (rg_cmpl$EN) rg_cmpl <= `BSV_ASSIGNMENT_DELAY rg_cmpl$D_IN;
	if (rg_go$EN) rg_go <= `BSV_ASSIGNMENT_DELAY rg_go$D_IN;
	if (rg_op1$EN) rg_op1 <= `BSV_ASSIGNMENT_DELAY rg_op1$D_IN;
	if (rg_read_data$EN)
	  rg_read_data <= `BSV_ASSIGNMENT_DELAY rg_read_data$D_IN;
	if (rg_result$EN) rg_result <= `BSV_ASSIGNMENT_DELAY rg_result$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_busy = 1'h0;
    rg_cmpl = 1'h0;
    rg_go = 1'h0;
    rg_op1 = 7'h2A;
    rg_read_data = 32'hAAAAAAAA;
    rg_result = 7'h2A;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (req_rd_cmd && !req_wr_cmd && req_addr != 2'b0 &&
	  req_addr != 2'b01 &&
	  req_addr != 2'b10)
	$display("LdpcTop: Bad read address: %03b", req_addr);
    if (RST_N != `BSV_RESET_VALUE)
      if (!req_rd_cmd && req_wr_cmd && req_addr == 2'b01)
	begin
	  v__h3128 = $stime;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (!req_rd_cmd && req_wr_cmd && req_addr == 2'b01)
	$display("(%0d): LdpcTop: Accepting code-word : %08h",
		 v__h3128,
		 req_wdata);
    if (RST_N != `BSV_RESET_VALUE)
      if (!req_rd_cmd && req_wr_cmd && req_addr != 2'b0 && req_addr != 2'b01)
	$display("LdpcTop: Bad write address: %02b", req_addr);
    if (RST_N != `BSV_RESET_VALUE)
      if (core$RDY_response_get)
	begin
	  v__h2296 = $stime;
	  #0;
	end
    if (RST_N != `BSV_RESET_VALUE)
      if (core$RDY_response_get)
	$display("(%0d): LdpcTop: Decoded code-word : %02h",
		 v__h2296,
		 core$response_get);
  end
  // synopsys translate_on
endmodule  // mkLdpcTop

