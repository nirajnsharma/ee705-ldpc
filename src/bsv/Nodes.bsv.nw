% vim: set tabstop=8:softtabstop=4:shiftwidth=4:textwidth:78:formatoptions+=t
\documentclass[11pt, a4paper]{article}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage{a4wide}  % Set margins automatically for wider use of A4

% ----------
% Margins
% Left margin, odd pages: ("0.125" + 1)
\setlength{\oddsidemargin}{0.125in}
% Left margin, even pages: ("0.125" + 1)
\setlength{\evensidemargin}{0.125in}
% Text width 6.5 inch (so other margin is 1 inch).
\setlength{\textwidth}{6.125in}
% ----------

\title{Nodes of the LDPC Decoder}
\author{Kim Jong Un}
\begin{document}
\maketitle

<<boilerplate>>=
// EE-705 Course Project -- LDPC Decoder

package Nodes;

// -----------------------------------------------------------------
// This package defines:
//
//    CheckNode   : Interface to the Check Nodes
//    BitNode     : Interface to the Bit Nodes
//    mkCheckNode : Micro-arch of the Check Node
//    mkBitNode   : Micro-arch of the Bit Node
//
//    v1.0        : The nodes can handle one code-word at a time
//
// -----------------------------------------------------------------

import ClientServer     :: *;
import GetPut           :: *;
import FIFO             :: *;
import Vector           :: *;
import LdpcTypes        :: *;

<<type definitions>>

<<module definition>>

@
The Bit-node and the Check-node are the two types of computation nodes in
the LDPC decoder. One iteration consists of processing at both of these
nodes. The interconnections between them is described by the incidence
matrix (H matrix).

<<type definitions>>=
<<interface definition>>

@
\section{Interfaces of the Bit and Check Nodes}
Two interface types, one each for the Bit and Check nodes are defined in
this package. Both interfaces are parameterized by the numeric types
[[NConnections]].

The numeric type, [[NConnections]] indicates the number of ones along a
particular row of the incidence matrix, which is also same as the number of
ones along a particular column of the incidence matrix.

<<interface definition>>=
// NConnections indicates the number of connections that a particular
// check-node has with the bit-nodes
interface CheckNode;
   interface Server #(Vector #(NConnections, Symbol), Symbol) iterate;
endinterface

@
A check node can be imagined to receive a vector of [[Symbol]] values from
different bit nodes, and that it returns a single [[Symbol]] values to all
bit nodes. As the check node works only when it receives a symbol from the
bit node, it can be thought of as the Server in a client-server protocol
with the bit node as the server.

<<interface definition>>=
// NConnections indicates the number of connections that a particular
// bit-node has with the check-nodes
interface BitNode;
   // Bit Node-Check Node Interface
   interface Client #(Symbol, Vector #(NConnections, Symbol)) iterate;

@
As far as the interface between the bit and check nodes are concerned, the
bit nodes connect to the check nodes with the client end of the
client-server protocol. This can be imagined as a protocol where the bit
node sends a \emph{request} to the check nodes in the form of a single
symbol and receives a vector of symbols as a \emph{response} from the check
nodes.

<<interface definition>>=

   // External interfaces for receving code word and returning result
   interface Put     #(Symbol)   codeIn;
   interface Get     #(Symbol)   dataOut;

endinterface

// -----------------------------------------------------------------

@
In addition to the [[iterate]] sub-interfaces to connect the check
and bit nodes, bit nodes also have the additional interfaces to receive the
code and send back the decoded data. Since each bit-node only deals with a
part of the code-word, it is sufficient to receive those symbols only. The
final decoded word is also constructed from the responses of the different
bit-nodes. Each bit node receives one symbol to decode at a time.

@
\section{The Bit Node}
The [[mkBitNode]] module receives the code word and initiates the
iterations.  Based on [[NConnections]] it is connected to a set of
[[mkCheckNodes]] representing the edges of the bipartite tanner graph. The
[[mkBitNode]] provides an interface of type [[BitNode]].

<<module definition>>=
//
// Module definition
module mkBitNode (BitNode #(NConnections));
   <<state bitNode>>
   <<rules bitNode>>
   <<interfaces bitNode>>
   <<wrap up bitNode>>
// -----------------------------------------------------------------

@
The input FIFO [[ffCodeIn]] receives the symbol of the code word meant for this
bit-node. The output FIFO [[ffDataOut]] holds the decoded symbol.

<<state bitNode>>=
// Sub-modules and state
// Input FIFO - code word
FIFO  #(Symbol)   ffCodeIn    <- mkFIFO;

// Output FIFO - decoded code word
FIFO  #(Symbol)   ffDataOut   <- mkFIFO;

@
The [[ffB2C]] FIFO holds the partially processed codeword. The contents of
this FIFO will be consumed by the check node when they are ready. The
[[ffC2B]] FIFO receives partially processed codewords from the check nodes
for the next iteration of processing.

<<state bitNode>>=
// Partially processed codeword meant for the checknodes
FIFO  #(Symbol)   ffB2C       <- mkFIFO;

// Partially processed codeword from the checknodes
FIFO  #(Vector #(
     NConnections
   , Symbol))     ffC2B       <- mkFIFO;

@
Behaviour is described in terms of atomic sets of actions called rules.
The rule [[rlProcessFirstIteration]] executes the actions for the first
iteration of processing a new code word. 

\begin{itemize}
\item Consume the codeword which is currently in [[ffCodeIn]]
\item Carry out the computation on the codeword
\item Enqueue the result into the [[ffB2C]] for checknode processing
\item Update the iteration count - this is updated by $2$ as the count is
maintained only in the bit node, and the check node acts as a purely
passive device.
\end{itemize}

<<rules bitNode>>=
// Rules and behaviour
<<functions bitNode>>

// Rule to process the first iteration of a new code word
rule rlProcessFirstIteration (rgIterationCount == 0);
   // As this is the first iteration, consume the codeword which is
   // currently in ffCodeIn. Carry out the computation on the codeword
   let codeIn = ffCodeIn.first; ffCodeIn.deq;
   let codeOut = fnBitNodeProcessing (codeIn);

   // Send the output to the check nodes
   ffB2C.enq (codeOut);
   
   // Bookkeeping - keep track of iterations to know when to stop
   rgIterationCount  <= rgIterationCount + 2;
endrule

@
The register, [[rgIterationCount]] keeps track of the number of iterations
for this particular code word. When a certain prefixed iteration limit is
reached, processing stops. This is a system-wide setting.

<<state bitNode>>=
Reg   #(Bit #(4))                rgIterationCount  <- mkReg (0);

// -----------------------------------------------------------------

@
The function [[fnBitNodeProcessing]], carries out the actual bit
manipulation of the codeword bits as per the XXX-insert-algorithm-here.

<<functions bitNode>>=
function Symbol fnBitNodeProcessing (Vector #(NConnections, Symbol) x);
   // XXX This is at present a dummy function which simply does an
   // XOR of the symbols
   // It will actually do some sort of a zip function which goes:
   // Vector#(N,Symbol) -> Symbol
   return (foldl1 (\^, x));
endfunction

@
The rule [[rlProcessRemIteration]] executes the actions for the remaining
iterations for processing a code word. The input for these iterations is
from the partially processed word in [[ffC2B]].

\begin{itemize}
\item Consume the codeword which is currently in [[ffC2B]]
\item Carry out the computation on the codeword
\item Enqueue the result into the [[ffB2C]] for checknode processing
\item Update the iteration count - this is updated by $2$ as the count is
maintained only in the bit node, and the check node acts as a purely
passive device.
\end{itemize}

<<rules bitNode>>=
// Rule to process remaining iterations
rule rlProcessRemIteration (
      (rgIterationCount > 0)
   && (rgIterationCount < fromInteger (valueOf (NumIteration))));
   // As this iteration works of a partial result from the checknode,
   // the input comes from ffC2B
   let codeIn = ffC2B.first; ffC2B.deq;
   let codeOut = fnBitNodeProcessing (codeIn);

   // Send the output to the check nodes
   ffB2C.enq (codeOut);
   
   // Bookkeeping - keep track of iterations to know when to stop
   rgIterationCount  <= rgIterationCount + 2;
endrule

@
The final rule of the three rules (which effectively describe a FSM),
simply copies the word from [[ffC2B]] to [[ffDataOut]], and resets the
counters for the next code word.

<<rules bitNode>>=
// Rule to complete processing on the bit node
rule rlProcessComplete (
   (rgIterationCount == fromInteger (valueOf (NumIteration))));
   // As this iteration works of a partial result from the checknode,
   // the input comes from ffC2B
   let codeIn = ffC2B.first; ffC2B.deq;
   let codeOut = fnBitNodeProcessing (codeIn);

   // Send the processed code word to the output
   ffDataOut.enq (codeOut);
   
   // Reset rgIterationCount for the next codeword
   rgIterationCount  <= 0;
endrule

// -----------------------------------------------------------------

@
Creating the interfaces simply involves stitching up the connections to the
input and output FIFOs using library functions -- [[toPut]], [[toGet]], and
[[toGPServer]].

<<interfaces bitNode>>=
// Interface
interface codeIn     = toPut (ffCodeIn);
interface dataOut    = toGet (ffDataOut);
interface iterate    = toGPServer (ffB2C, ffC2B);
endinterface

// -----------------------------------------------------------------

<<wrap up bitNode>>=
endmodule : mkBitNode

@
\section{The Check Node}
The [[mkCheckNode]] module receives the partially decoded code word from
the [[mkBitNode]]. It operates in \emph{slave} mode and processes all
inputs in the same manner. The [[mkCheckNode]] does not keep track of
iterations. The [[mkCheckNode]] provides an interface of type [[CheckNode]].

<<module definition>>=
//
// Module definition
module mkCheckNode (CheckNode);
   <<state checkNode>>
   <<rules checkNode>>
   <<interfaces checkNode>>
   <<wrap up checkNode>>
// -----------------------------------------------------------------

@
The input FIFO [[ffB2C]] receives the partially processed part of the code
word meant for this check-node. The output FIFO [[ffC2B]] holds the
partially decoded code word.

<<state checkNode>>=
// Sub-modules and state
// Input FIFO - code word
FIFO  #(Vector #(
     NConnections
   , Symbol))     ffB2C          <- mkFIFO;

// Output FIFO - decoded code word
FIFO  #(Symbol)    ffC2B         <- mkFIFO;

@
The rule [[rlProcessIteration]] executes the actions for process the
input from the bit nodes.

\begin{itemize}
\item Consume the codeword which is currently in [[ffCodeIn]]
\item Carry out the computation on the codeword
\item Enqueue the result into the [[ffB2C]] for checknode processing
\item Update the iteration count - this is updated by $2$ as the count is
maintained only in the bit node, and the check node acts as a purely
passive device.
\end{itemize}

<<rules checkNode>>=
// Rules and behaviour
<<functions checkNode>>
rule rlProcessIteration;
   // get the partial result
   let codeIn = ffB2C.first; ffB2C.deq;

   // Process the partial result further
   let codeOut = fnCheckNodeProcessing (codeIn);

   // Send the partial result to the bit node
   ffC2B.enq (codeOut);
endrule

// -----------------------------------------------------------------

@
The function [[fnCheckNodeProcessing]], carries out the actual bit
manipulation of the codeword bits as per the XXX-insert-algorithm-here.

<<functions checkNode>>=
function Symbol fnCheckNodeProcessing (Vector #(NConnections, Symbol) x);
   // XXX This is at present a dummy function which simply does an
   // inverting of the bits
   // It will actually do some sort of a zip function which goes:
   // Vector#(N,Symbol) -> Symbol
   return (foldl1 (\^, x));
endfunction

@
Creating the interfaces simply involves stitching up the connections to the
input and output FIFOs using library functions -- [[toPut]] and [[toGet]].

<<interfaces checkNode>>=
// Interface
interface iterate = toGPClient (ffB2C, ffC2B);

// -----------------------------------------------------------------

<<wrap up checkNode>>=
endmodule : mkCheckNode
endpackage

@
\end{document}

