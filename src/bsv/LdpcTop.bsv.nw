% vim: set tabstop=8:softtabstop=4:shiftwidth=4:textwidth:78:formatoptions+=t
\documentclass[11pt, a4paper]{article}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage{a4wide}  % Set margins automatically for wider use of A4

% ----------
% Margins
% Left margin, odd pages: ("0.125" + 1)
\setlength{\oddsidemargin}{0.125in}
% Left margin, even pages: ("0.125" + 1)
\setlength{\evensidemargin}{0.125in}
% Text width 6.5 inch (so other margin is 1 inch).
\setlength{\textwidth}{6.125in}
% ----------

\title{LDPC Decoder Top-level}
\author{Kim Jong Un}
\begin{document}
\maketitle

<<boilerplate>>=
// EE-705 Course Project -- LDPC Decoder

package Nodes;

// -----------------------------------------------------------------
// This package defines:
//
//    CheckNode   : Interface to the Check Nodes
//    BitNode     : Interface to the Bit Nodes
//    mkCheckNode : Micro-arch of the Check Node
//    mkBitNode   : Micro-arch of the Bit Node
//
//    v1.0        : The nodes can handle one code-word at a time
//
// -----------------------------------------------------------------

import GetPut           :: *;
import ClientServer     :: *;
import FIFO             :: *;
import Vector           :: *;
import LdpcTypes        :: *;
import Nodes            :: *;

<<type definitions>>

<<interface definition>>

<<module definition>>

@
This is the top-level of the LDPC decoder. It integrates all the
bit-nodes and check-nodes. Global types for the LDPC decoder are defined
in [[LdpcTypes]] package.

The following types are global:

\begin{description}
\item[Symbol:] The bit pattern describing a soft-value
\item[DataWord:] A collection of soft-value forming the code word or the
decoded word
\item[NumBitNodes:] The number of bit nodes. In this design each bit
node manipulates a symbol. So, the number of bit nodes is same as the
number of symbols.
\item[CheckBitNodes:] The number of check nodes. In this design each
check node manipulates a symbol. So, the number of bit nodes is same as the
number of symbols.
\item[NumIteration:] Number of iterations between bit node and check
nodes.
\end{description}

<<type definitions>>=
package LdpcTypes;
// Global types used across the design
// Soft-value bit pattern
typedef Bit #(4) Symbol;

// A coded/decoded word
typedef Vector #(CodeLength, Symbol) DataWord;

// Number of bit nodes
typedef CodeLength NumBitNodes;

// Number of check nodes
typedef CodeLength NumCheckNodes;

// Number of iterations between bit nodes and check nodes
typedef 8 NumIteration;
endpackage : LdpcTypes

@
The LDPC decoder top-level provides a Server interface which receives a
code word as request and responds with the decoded code word.

<<interface definition>>=
typedef Server #(DataWord, DataWord) LdpcTop;

// -----------------------------------------------------------------

@
\section{The LDPC Top-level}
The number of bit-nodes and check-nodes depend on the topology of the
tanner graph. For a given topology, the number of bit-nodes and the
number of check-nodes are inputs. These are defined in [[LdpcTypes]].

<<module definition>>=
module mkLdpcTop (LdpcTop);
   <<state>>
   <<rules>>
   <<interfaces>>
<<wrap up>>

@
The bit-nodes and check-nodes are instantiated as vectors of modules
with the number of elements defined by the numeric types
[[NumBitNodes]] and [[NumCheckNodes]].

<<state>>=
// Bit nodes
Vector #(NumBitNodes, BitNode) vBitNodes <- replicateM (mkBitNode);

// Check nodes
Vector #(NumCheckNodes, CheckNode) vCheckNodes <- replicateM (mkCheckNode);

@
Finally, we will need a pair of FIFOs to accept the code word on the
input side and buffer the decoded word on the output side.

<<state>>=
// Input and output FIFOs
FIFO #(DataWord) ffI <- mkFIFO;
FIFO #(DataWord) ffO <- mkFIFO;

@
At the top-level every rule reads from the transmitting end (bit or
check node), and writes to the receiving end (bit or check node). These
[[connections]] are autogenerated from the same python script which
generates the [[LdpcTypes]].

<<rules>>=
// Connect up all the bit nodes and check nodes
mkLdpcConnections (vBitNodes, vCheckNodes);

@
While the connections between bit and check nodes take care of all the
communication between the nodes for each iteration, the input code-word
still needs to be input to the bit nodes and the decoded word needs to be
output from the bit nodes. 

<<rules>>=
rule rl

@
The [[LdpcDecode]] interface simply does the connections to the [[ffI]]
and [[ffO]] FIFOs.

<<interfaces>>=
return (toGPServer (ffI, ffO));

<<wrap up>>=
endmodule : mkLdpcTop
endpackage

@
\end{document}

