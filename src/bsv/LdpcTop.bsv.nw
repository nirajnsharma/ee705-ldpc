% vim: set tabstop=8:softtabstop=4:shiftwidth=4:textwidth:78:formatoptions+=t
\documentclass[11pt, a4paper]{article}
\usepackage{noweb}
\usepackage{amsmath}
\usepackage{a4wide}  % Set margins automatically for wider use of A4

% ----------
% Margins
% Left margin, odd pages: ("0.125" + 1)
\setlength{\oddsidemargin}{0.125in}
% Left margin, even pages: ("0.125" + 1)
\setlength{\evensidemargin}{0.125in}
% Text width 6.5 inch (so other margin is 1 inch).
\setlength{\textwidth}{6.125in}
% ----------

\title{LDPC Decoder Core Top-level}
\author{Kim Jong Un}
\begin{document}
\maketitle

<<boilerplate>>=
// EE-705 Course Project -- LDPC Decoder

package LdpcTop;

// -----------------------------------------------------------------
// This package defines:
//
//    LdpcCore    : Interface of the LDPC Core module
//    mkLdpcCore  : Top-level module of the LDPC core
//
//    v1.0        : Non-pipelined. The nodes can handle one code-word
//                  at a time
//
// -----------------------------------------------------------------

import GetPut           :: *;
import ClientServer     :: *;
import FIFO             :: *;
import Vector           :: *;
import LdpcTypes        :: *;
import Nodes            :: *;

<<interface definition>>

<<LdpcCore module definition>>

<<conn module definition>>

@
This is the top-level of the LDPC decoder. It integrates all the
bit-nodes and check-nodes. Global types for the LDPC decoder are defined
in [[LdpcTypes]] package.

The following types are global:

\begin{description}
\item[Symbol:] The bit pattern describing a soft-value
\item[DataWord:] A collection of soft-value forming the code word or the
decoded word
\item[NumBitNodes:] The number of bit nodes. In this design each bit
node manipulates a symbol. So, the number of bit nodes is same as the
number of symbols.
\item[CheckBitNodes:] The number of check nodes. In this design each
check node manipulates a symbol. So, the number of bit nodes is same as the
number of symbols.
\item[NRConnections:] Number of 1s in a row of the H matrix. Represents the
fanouts/fanin from/to a check-node.
\item[NCConnections:] Number of 1s in a column of the H matrix. Represents
the fanouts/fanin from/to a bit-node.
\item[NumIteration:] Number of iterations between bit node and check
nodes.
\end{description}

<<type definitions>>=
package LdpcTypes;
import Vector :: *;

// Global types used across the design
// Soft-value bit pattern
typedef Bit #(4) Symbol;

// A coded/decoded word
typedef Vector #(CodeLength, Symbol) DataWord;

// Number of bit nodes
typedef CodeLength NumBitNodes;

// Number of check nodes
typedef CodeLength NumCheckNodes;

// Fanouts from an individual check-node. This is the number of 1s in a row of
// the H-matrix
typedef 3 NRConnections;

// Fanouts from an individual bit-node. This is the number of 1s in a column
// of the H-matrix
typedef 3 NCConnections;

// Number of iterations between bit nodes and check nodes
typedef 8 NumIteration;
endpackage : LdpcTypes

@
The LDPC decoder top-level provides a Server interface which receives a
code word as request and responds with the decoded code word.

<<interface definition>>=
typedef Server #(DataWord, DataWord) LdpcCore;

// -----------------------------------------------------------------

@
\section{The LDPC Core Top-level}
The number of bit-nodes and check-nodes depend on the topology of the
tanner graph. For a given topology, the number of bit-nodes and the
number of check-nodes are inputs. These are defined in [[LdpcTypes]].

<<LdpcCore module definition>>=
module mkLdpcCore (LdpcCore);
   <<state>>
   <<rules>>
   <<interfaces>>
   <<wrap up mkLdpcCore>>

@
The bit-nodes and check-nodes are instantiated as vectors of modules
with the number of elements defined by the numeric types
[[NumBitNodes]] and [[NumCheckNodes]].

<<state>>=
// Bit nodes
Vector #(NumBitNodes, BitNode) vBitNodes <- replicateM (mkBitNode);

// Check nodes
Vector #(NumCheckNodes, CheckNode) vCheckNodes <- replicateM (mkCheckNode);

@
Finally, we will need a pair of FIFOs to accept the code word on the
input side and buffer the decoded word on the output side.

<<state>>=
// Input and output FIFOs
FIFO #(DataWord) ffI <- mkFIFO;
FIFO #(DataWord) ffO <- mkFIFO;

@
At the top-level every rule reads from the transmitting end (bit or
check node), and writes to the receiving end (bit or check node). These
[[connections]] may also be autogenerated from a high-level script. The
following connections are as per the matrix:

\[
H = \begin{bmatrix}
1 1 0 1 0 0 0 \\
0 1 1 0 1 0 0 \\
0 0 1 1 0 1 0 \\
0 0 0 1 1 0 1 \\
1 0 0 0 1 1 0 \\
0 1 0 0 0 1 1 \\
1 0 1 0 0 0 1 \\
\end{bmatrix}
\]

<<rules>>=
// connect up all the bit nodes and check nodes
// bit-node to check-node connections
mkConnMulti (
     vBitNodes[0].b2c
   , vCheckNodes[0].b2c[0], vCheckNodes[4].b2c[0], vCheckNodes[6].b2c[0]);
mkConnMulti (
     vBitNodes[1].b2c
   , vCheckNodes[0].b2c[1], vCheckNodes[1].b2c[0], vCheckNodes[5].b2c[0]);
mkConnMulti (
     vBitNodes[2].b2c
   , vCheckNodes[1].b2c[1], vCheckNodes[2].b2c[0], vCheckNodes[6].b2c[1]);
mkConnMulti (
     vBitNodes[3].b2c
   , vCheckNodes[0].b2c[2], vCheckNodes[2].b2c[1], vCheckNodes[3].b2c[0]);
mkConnMulti (
     vBitNodes[4].b2c
   , vCheckNodes[1].b2c[2], vCheckNodes[3].b2c[1], vCheckNodes[4].b2c[1]);
mkConnMulti (
     vBitNodes[5].b2c
   , vCheckNodes[2].b2c[2], vCheckNodes[4].b2c[2], vCheckNodes[5].b2c[1]);
mkConnMulti (
     vBitNodes[6].b2c
   , vCheckNodes[3].b2c[2], vCheckNodes[5].b2c[2], vCheckNodes[6].b2c[2]);

// check-node to bit-node connections
mkConnMulti (
     vCheckNodes[0].c2b
   , vBitNodes[0].c2b[0], vBitNodes[1].c2b[0], vBitNodes[3].c2b[0]);

mkConnMulti (
     vCheckNodes[1].c2b
   , vBitNodes[1].c2b[1], vBitNodes[2].c2b[0], vBitNodes[4].c2b[0]);

mkConnMulti (
     vCheckNodes[2].c2b
   , vBitNodes[2].c2b[1], vBitNodes[3].c2b[1], vBitNodes[5].c2b[0]);

mkConnMulti (
     vCheckNodes[3].c2b
   , vBitNodes[3].c2b[2], vBitNodes[4].c2b[1], vBitNodes[6].c2b[0]);

mkConnMulti (
     vCheckNodes[4].c2b
   , vBitNodes[0].c2b[1], vBitNodes[4].c2b[2], vBitNodes[5].c2b[1]);

mkConnMulti (
     vCheckNodes[5].c2b
   , vBitNodes[1].c2b[2], vBitNodes[5].c2b[2], vBitNodes[6].c2b[1]);

mkConnMulti (
     vCheckNodes[6].c2b
   , vBitNodes[0].c2b[2], vBitNodes[2].c2b[2], vBitNodes[6].c2b[2]);

@
The connections between bit and check nodes take care of all the
communication between the nodes for each iteration. These connections have
been abstracted in the module [[mkConnMulti]]. This module
takes the interfaces being connected as arguments and returns the logic to
connect them up.

<<conn module definition>>=
module mkConnMulti #(
     Get #(Symbol) src
   , Put #(Symbol) dst1
   , Put #(Symbol) dst2
   , Put #(Symbol) dst3)

   <<conn rule>>

   <<conn wrap up>>

@
One rule describes the connectable's behaviour. It connects
the outgoing symbol from the source node as incoming symbols to multiple
destination nodes.

<<conn rule>>=
   // Connect a "SRC" to a "DST"
   rule rlConnect ();
      let s <- src.get();
      dst1.put (s); dst2.put (s); dst3.put (s);
   endrule

In order to get things started, the input code-word needs to be input
to the bit nodes. The input code word will be sitting in the [[ffI]] FIFO.
In the current architecture, we are sending one symbol per bit-node. In
general, it is possible to fold multiple symbols onto a bit node but this
will require more complex nodes.

A code-word can be sent to all bit-nodes only when all of them are ready to
receive the code words.

<<rules>>=
rule rlPutCodeWordIn;
   // Get the codeword from ffI
   let codeIn = ffI.first; ffI.deq;

   // Send each bit-node a symbol
   for (Integer i=0; i<valueOf(NumBitNodes); i=i+1)
      vCheckNodes[i].codeIn.put (codeIn[i]);
endrule

@
At the output end, the decoded symbols are collected from the bit-nodes and
sent to the [[ffO]]. Again, one symbol each is connected from every
bit-node in this architecture. Decoded words can be collected from all the
bit-nodes only when all of them are ready with their decoded symbols.

<<rules>>=
rule rlGetDecodedWordOut;
   DataWord dOut;

   // Get a symbol from each bit-node
   for (Integer i=0; i<valueOf(NumBitNodes); i=i+1) begin
      let d <- vCheckNodes[i].dataOut.get ();
      dOut [i] = d;
   end

   // Write the collected symbols into the output fifo
   ffO.enq (dOut);
endrule

@
The [[LdpcDecode]] interface simply does the connections to the [[ffI]]
and [[ffO]] FIFOs.

<<interfaces>>=
return (toGPServer (ffI, ffO));

<<wrap up mkLdpcCore>>=
endmodule : mkLdpcCore

<<conn wrap up>>=
endmodule
endpackage

@
\end{document}

