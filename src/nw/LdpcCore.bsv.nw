% vim: set tabstop=8:softtabstop=4:shiftwidth=4:textwidth:78:formatoptions+=t
\section{LDPC Decoder Core Top-level}
The LDPC core integrates the bit and check nodes as per the topology specified
by the $H$ matrix.

<<boilerplate>>=
// EE-705 Course Project -- LDPC Decoder

package LdpcCore;

// -----------------------------------------------------------------
// This package defines:
//
//    LdpcCore    : Interface of the LDPC Core module
//    mkLdpcCore  : Top-level module of the LDPC core
//
//    v1.0        : Non-pipelined. The nodes can handle one code-word
//                  at a time
//
// -----------------------------------------------------------------

import GetPut           :: *;
import ClientServer     :: *;
import Connectable      :: *;
import FIFO             :: *;
import Vector           :: *;
import LdpcTypes        :: *;
import Nodes            :: *;

<<interface definition>>

<<LdpcCore module definition>>

<<conn module definition>>

@
Global types for the LDPC decoder are defined in [[LdpcTypes]] package. The
following types are global:

\begin{description}
\item[Symbol:] The bit pattern describing a soft-value
\item[DataWord:] A collection of soft-value forming the code word or the
decoded word
\item[CodeLength:] The number of symbols in a DataWord. In this configuration,
this is equal to the number of bit nodes and check nodes
\item[NBitNodes:] The number of bit nodes. In this design each bit
node manipulates a symbol. So, the number of bit nodes is same as the
number of symbols.
\item[NCheckNodes:] The number of check nodes. In this design each
check node manipulates a symbol. So, the number of check nodes is same as the
number of symbols.
\item[NConnections:] Number of 1s in a row of the H matrix. Represents the
fanouts/fanin from/to a check-node. Is also the number of 1s in a column of the
H matrix, which represents the fanouts/fanin from/to a bit node.
\item[NIteration:] Number of iterations between bit node and check
nodes.
\end{description}

<<type definitions>>=
package LdpcTypes;
import Vector :: *;

// Global types used across the design
// Soft-value bit pattern
typedef Bit #(1) Symbol;

// Number of symbols in a codeword
typedef 7 CodeLength;

// A coded/decoded word
typedef Vector #(CodeLength, Symbol) DataWord;

// Number of bit nodes
typedef CodeLength NBitNodes;

// Number of check nodes
typedef CodeLength NCheckNodes;

// Fanouts from an individual check-node. This is the number of 1s in a row of
// the H-matrix
typedef 3 NConnections;

// Number of iterations between bit nodes and check nodes
// typedef 8 NIterations;
endpackage : LdpcTypes

@
The LDPC decoder top-level provides a Server interface which receives a
code word as request and responds with the decoded code word.

<<interface definition>>=
typedef Server #(DataWord, DataWord) LdpcCore;

// -----------------------------------------------------------------

@
\section{The LDPC Core Top-level}
The number of bit-nodes and check-nodes depend on the topology of the
tanner graph. For a given topology, the number of bit-nodes and the
number of check-nodes are inputs. These are defined in [[LdpcTypes]].

<<LdpcCore module definition>>=
<<check function>>

(* synthesize *)
module mkLdpcCore (LdpcCore);
   <<state>>
   <<rules>>
   <<interfaces>>
   <<wrap up mkLdpcCore>>

@
The bit-nodes and check-nodes are instantiated as vectors of modules
with the number of elements defined by the numeric types
[[NBitNodes]] and [[NCheckNodes]].

<<state>>=
// Bit nodes
Vector #(NBitNodes, BitNode) vBitNodes <- replicateM (mkBitNode);

// Check nodes
Vector #(NCheckNodes, ChkNode) vCheckNodes <- replicateM (mkChkNode);

@
Finally, we will need a pair of FIFOs to accept the code word on the
input side and buffer the decoded word on the output side.

<<state>>=
// Input and output FIFOs
FIFO #(DataWord) ffI <- mkFIFO;
FIFO #(DataWord) ffO <- mkFIFO;

@
At the top-level every rule reads from the transmitting end (bit or
check node), and writes to the receiving end (bit or check node). These
[[connections]] may also be autogenerated from a high-level script. The
following connections are as per the matrix:

\[
H = \begin{bmatrix}
1 1 0 1 0 0 0 \\
0 1 1 0 1 0 0 \\
0 0 1 1 0 1 0 \\
0 0 0 1 1 0 1 \\
1 0 0 0 1 1 0 \\
0 1 0 0 0 1 1 \\
1 0 1 0 0 0 1 \\
\end{bmatrix}
\]

<<rules>>=
// connect up all the bit nodes and check nodes
// bit-node to check-node connections
mkConnMulti (
     vBitNodes[0].b2c
   , vCheckNodes[0].b2c[0], vCheckNodes[4].b2c[0], vCheckNodes[6].b2c[0]);
mkConnMulti (
     vBitNodes[1].b2c
   , vCheckNodes[0].b2c[1], vCheckNodes[1].b2c[0], vCheckNodes[5].b2c[0]);
mkConnMulti (
     vBitNodes[2].b2c
   , vCheckNodes[1].b2c[1], vCheckNodes[2].b2c[0], vCheckNodes[6].b2c[1]);
mkConnMulti (
     vBitNodes[3].b2c
   , vCheckNodes[0].b2c[2], vCheckNodes[2].b2c[1], vCheckNodes[3].b2c[0]);
mkConnMulti (
     vBitNodes[4].b2c
   , vCheckNodes[1].b2c[2], vCheckNodes[3].b2c[1], vCheckNodes[4].b2c[1]);
mkConnMulti (
     vBitNodes[5].b2c
   , vCheckNodes[2].b2c[2], vCheckNodes[4].b2c[2], vCheckNodes[5].b2c[1]);
mkConnMulti (
     vBitNodes[6].b2c
   , vCheckNodes[3].b2c[2], vCheckNodes[5].b2c[2], vCheckNodes[6].b2c[2]);

@
The bit-node-to-check-node connections are a broadcast of single symbol to
multiple check nodes.  These connections have been abstracted in the module
[[mkConnMulti]]. This module takes the interfaces being connected as arguments
and returns the logic to connect them up.

<<conn module definition>>=
module mkConnMulti #(
     Get #(Symbol) src
   , Put #(Symbol) dst1
   , Put #(Symbol) dst2
   , Put #(Symbol) dst3) (Empty);

   <<conn rule>>

<<conn wrap up>>

@
One rule describes the connectable's behaviour. It connects
the outgoing symbol from the source node as incoming symbols to multiple
destination nodes.

<<conn rule>>=
   // Connect a "SRC" to a "DST"
   rule rlConnect;
      let s <- src.get();
      dst1.put (s); dst2.put (s); dst3.put (s);
   endrule

@
The check-node-to-bit-node connections are one-to-one. We do not need to
create a new abstraction for this as there is a [[mkConnection]] abstraction
which does this for get and put interfaces.

<<rules>>=

// check-node to bit-node connections
// From check-node 0
mkConnection (vCheckNodes[0].c2b[0], vBitNodes[0].c2b[0]);
mkConnection (vCheckNodes[0].c2b[1], vBitNodes[1].c2b[0]);
mkConnection (vCheckNodes[0].c2b[2], vBitNodes[3].c2b[0]);

// From check-node 1
mkConnection (vCheckNodes[1].c2b[0], vBitNodes[1].c2b[1]);
mkConnection (vCheckNodes[1].c2b[1], vBitNodes[2].c2b[0]);
mkConnection (vCheckNodes[1].c2b[2], vBitNodes[4].c2b[0]);

// From check-node 2
mkConnection (vCheckNodes[2].c2b[0], vBitNodes[2].c2b[1]);
mkConnection (vCheckNodes[2].c2b[1], vBitNodes[3].c2b[1]);
mkConnection (vCheckNodes[2].c2b[2], vBitNodes[5].c2b[0]);

// From check-node 3
mkConnection (vCheckNodes[3].c2b[0], vBitNodes[3].c2b[2]);
mkConnection (vCheckNodes[3].c2b[1], vBitNodes[4].c2b[1]);
mkConnection (vCheckNodes[3].c2b[2], vBitNodes[6].c2b[0]);

// From check-node 4
mkConnection (vCheckNodes[4].c2b[0], vBitNodes[0].c2b[1]);
mkConnection (vCheckNodes[4].c2b[1], vBitNodes[4].c2b[2]);
mkConnection (vCheckNodes[4].c2b[2], vBitNodes[5].c2b[1]);

// From check-node 5
mkConnection (vCheckNodes[5].c2b[0], vBitNodes[1].c2b[2]);
mkConnection (vCheckNodes[5].c2b[1], vBitNodes[5].c2b[2]);
mkConnection (vCheckNodes[5].c2b[2], vBitNodes[6].c2b[1]);

// From check-node 6
mkConnection (vCheckNodes[6].c2b[0], vBitNodes[0].c2b[2]);
mkConnection (vCheckNodes[6].c2b[1], vBitNodes[2].c2b[2]);
mkConnection (vCheckNodes[6].c2b[2], vBitNodes[6].c2b[2]);

@
In order to get things started, the input code-word needs to be input
to the bit nodes. The input code word will be sitting in the [[ffI]] FIFO.
In the current architecture, we are sending one symbol per bit-node. In
general, it is possible to fold multiple symbols onto a bit node but this
will require more complex nodes.

A code-word can be sent to all bit-nodes only when all of them are ready to
receive the code words.

<<rules>>=
rule rlPutCodeWordIn (rgIdle);
   // Get the codeword from ffI
   let codeIn = ffI.first; ffI.deq;
   
   // The decoder is busy now
   rgIdle <= False;

   // Send each bit-node a symbol
   for (Integer i=0; i<valueOf(NBitNodes); i=i+1)
      vBitNodes[i].codeIn.put (codeIn[i]);

`ifdef DBG
   $display ("(%5d)::LdpcCore::rlPutCodeWordIn::%07b", $time, codeIn);
`endif
endrule

@
After every iteration, each bit-nodes return a symbol. All of these need to be
collated and checked to see if the decoding is complete. If not, they are sent
back to the bit nodes for another round of processing.

<<rules>>=
rule rlEvaluateOutput (!rgIdle);
   DataWord vBitNodeOuts;
   for (Integer i=0; i<valueOf(NBitNodes); i=i+1) begin
      let d <- vBitNodes[i].dataOut.get();
      vBitNodeOuts[i] = d;
   end

`ifdef DBG
   $display ("(%5d)::LdpcCore::rlEvaluateOutput::%07b", $time, pack (vBitNodeOuts));
`endif

   // Check if the decoding is complete
   // Decoding is good
   if (fnCheckDecodedWord (vBitNodeOuts) == 1'b0) begin
      ffO.enq (vBitNodeOuts);
      rgIdle <= True;
`ifdef DBG
      $display ("(%5d)::LdpcCore::rlEvaluateOutput::Decoding Okay", $time);
`endif
   end

   // Decoding is not complete - back to the bit node
   else begin
`ifdef DBG
      $display ("(%5d)::LdpcCore::rlEvaluateOutput::Decoding not okay. Back to bit-node", $time);
`endif
      // Send each bit-node a symbol
      for (Integer i=0; i<valueOf(NBitNodes); i=i+1)
         vBitNodes[i].codeIn.put (vBitNodeOuts[i]);
   end
endrule

@
The register [[rgIdle]] differentiates between whether the decoder is busy
with an existing codeword or is waiting for new input.

<<state>>=
Reg #(Bool) rgIdle <- mkReg(True);

@
At the output end, the decoded symbols are collected from the bit-nodes and
sent to the [[ffO]]. This is done if the [[fnCheckDecodedWord]] returns a
positive result (no error).

<<check function>>=
(* noinline *)
function Bit#(1) fnCheckDecodedWord (DataWord b);
return (
      (b[0]^b[1]^b[3])
    | (b[1]^b[2]^b[4])
    | (b[2]^b[3]^b[5])
    | (b[3]^b[4]^b[6])
    | (b[0]^b[4]^b[5])
    | (b[1]^b[5]^b[6])
    | (b[0]^b[2]^b[6]));
endfunction

@
The [[LdpcDecode]] interface simply does the connections to the [[ffI]]
and [[ffO]] FIFOs.

<<interfaces>>=
return (toGPServer (ffI, ffO));

<<wrap up mkLdpcCore>>=
endmodule : mkLdpcCore

<<conn wrap up>>=
endmodule : mkConnMulti
endpackage : LdpcCore
