//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Tue Apr 16 14:00:55 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// RDY_c2b_0_put                  O     1 reg
// RDY_c2b_1_put                  O     1 reg
// RDY_c2b_2_put                  O     1 reg
// b2c_get                        O     4 reg
// RDY_b2c_get                    O     1 reg
// RDY_codeIn_put                 O     1 reg
// dataOut_get                    O     4 reg
// RDY_dataOut_get                O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// c2b_0_put                      I     4 reg
// c2b_1_put                      I     4 reg
// c2b_2_put                      I     4 reg
// codeIn_put                     I     4 reg
// EN_c2b_0_put                   I     1
// EN_c2b_1_put                   I     1
// EN_c2b_2_put                   I     1
// EN_codeIn_put                  I     1
// EN_b2c_get                     I     1
// EN_dataOut_get                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBitNode(CLK,
		 RST_N,

		 c2b_0_put,
		 EN_c2b_0_put,
		 RDY_c2b_0_put,

		 c2b_1_put,
		 EN_c2b_1_put,
		 RDY_c2b_1_put,

		 c2b_2_put,
		 EN_c2b_2_put,
		 RDY_c2b_2_put,

		 EN_b2c_get,
		 b2c_get,
		 RDY_b2c_get,

		 codeIn_put,
		 EN_codeIn_put,
		 RDY_codeIn_put,

		 EN_dataOut_get,
		 dataOut_get,
		 RDY_dataOut_get);
  input  CLK;
  input  RST_N;

  // action method c2b_0_put
  input  [3 : 0] c2b_0_put;
  input  EN_c2b_0_put;
  output RDY_c2b_0_put;

  // action method c2b_1_put
  input  [3 : 0] c2b_1_put;
  input  EN_c2b_1_put;
  output RDY_c2b_1_put;

  // action method c2b_2_put
  input  [3 : 0] c2b_2_put;
  input  EN_c2b_2_put;
  output RDY_c2b_2_put;

  // actionvalue method b2c_get
  input  EN_b2c_get;
  output [3 : 0] b2c_get;
  output RDY_b2c_get;

  // action method codeIn_put
  input  [3 : 0] codeIn_put;
  input  EN_codeIn_put;
  output RDY_codeIn_put;

  // actionvalue method dataOut_get
  input  EN_dataOut_get;
  output [3 : 0] dataOut_get;
  output RDY_dataOut_get;

  // signals for module outputs
  wire [3 : 0] b2c_get, dataOut_get;
  wire RDY_b2c_get,
       RDY_c2b_0_put,
       RDY_c2b_1_put,
       RDY_c2b_2_put,
       RDY_codeIn_put,
       RDY_dataOut_get;

  // register rgIterationCount
  reg [3 : 0] rgIterationCount;
  wire [3 : 0] rgIterationCount$D_IN;
  wire rgIterationCount$EN;

  // ports of submodule ffB2C
  wire [3 : 0] ffB2C$D_IN, ffB2C$D_OUT;
  wire ffB2C$CLR, ffB2C$DEQ, ffB2C$EMPTY_N, ffB2C$ENQ, ffB2C$FULL_N;

  // ports of submodule ffCodeIn
  wire [3 : 0] ffCodeIn$D_IN, ffCodeIn$D_OUT;
  wire ffCodeIn$CLR,
       ffCodeIn$DEQ,
       ffCodeIn$EMPTY_N,
       ffCodeIn$ENQ,
       ffCodeIn$FULL_N;

  // ports of submodule ffDataOut
  wire [3 : 0] ffDataOut$D_IN, ffDataOut$D_OUT;
  wire ffDataOut$CLR,
       ffDataOut$DEQ,
       ffDataOut$EMPTY_N,
       ffDataOut$ENQ,
       ffDataOut$FULL_N;

  // ports of submodule vffC2B_0
  wire [3 : 0] vffC2B_0$D_IN, vffC2B_0$D_OUT;
  wire vffC2B_0$CLR,
       vffC2B_0$DEQ,
       vffC2B_0$EMPTY_N,
       vffC2B_0$ENQ,
       vffC2B_0$FULL_N;

  // ports of submodule vffC2B_1
  wire [3 : 0] vffC2B_1$D_IN, vffC2B_1$D_OUT;
  wire vffC2B_1$CLR,
       vffC2B_1$DEQ,
       vffC2B_1$EMPTY_N,
       vffC2B_1$ENQ,
       vffC2B_1$FULL_N;

  // ports of submodule vffC2B_2
  wire [3 : 0] vffC2B_2$D_IN, vffC2B_2$D_OUT;
  wire vffC2B_2$CLR,
       vffC2B_2$DEQ,
       vffC2B_2$EMPTY_N,
       vffC2B_2$ENQ,
       vffC2B_2$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rlProcessFirstIteration,
       CAN_FIRE_RL_rlProcessRemIteration,
       CAN_FIRE_b2c_get,
       CAN_FIRE_c2b_0_put,
       CAN_FIRE_c2b_1_put,
       CAN_FIRE_c2b_2_put,
       CAN_FIRE_codeIn_put,
       CAN_FIRE_dataOut_get,
       WILL_FIRE_RL_rlProcessFirstIteration,
       WILL_FIRE_RL_rlProcessRemIteration,
       WILL_FIRE_b2c_get,
       WILL_FIRE_c2b_0_put,
       WILL_FIRE_c2b_1_put,
       WILL_FIRE_c2b_2_put,
       WILL_FIRE_codeIn_put,
       WILL_FIRE_dataOut_get;

  // inputs to muxes for submodule ports
  wire [3 : 0] MUX_ffB2C$enq_1__VAL_1,
	       MUX_rgIterationCount$write_1__VAL_1,
	       MUX_rgIterationCount$write_1__VAL_2;
  wire MUX_ffB2C$enq_1__SEL_1;

  // remaining internal signals
  wire [3 : 0] x__h1193;

  // action method c2b_0_put
  assign RDY_c2b_0_put = vffC2B_0$FULL_N ;
  assign CAN_FIRE_c2b_0_put = vffC2B_0$FULL_N ;
  assign WILL_FIRE_c2b_0_put = EN_c2b_0_put ;

  // action method c2b_1_put
  assign RDY_c2b_1_put = vffC2B_1$FULL_N ;
  assign CAN_FIRE_c2b_1_put = vffC2B_1$FULL_N ;
  assign WILL_FIRE_c2b_1_put = EN_c2b_1_put ;

  // action method c2b_2_put
  assign RDY_c2b_2_put = vffC2B_2$FULL_N ;
  assign CAN_FIRE_c2b_2_put = vffC2B_2$FULL_N ;
  assign WILL_FIRE_c2b_2_put = EN_c2b_2_put ;

  // actionvalue method b2c_get
  assign b2c_get = ffB2C$D_OUT ;
  assign RDY_b2c_get = ffB2C$EMPTY_N ;
  assign CAN_FIRE_b2c_get = ffB2C$EMPTY_N ;
  assign WILL_FIRE_b2c_get = EN_b2c_get ;

  // action method codeIn_put
  assign RDY_codeIn_put = ffCodeIn$FULL_N ;
  assign CAN_FIRE_codeIn_put = ffCodeIn$FULL_N ;
  assign WILL_FIRE_codeIn_put = EN_codeIn_put ;

  // actionvalue method dataOut_get
  assign dataOut_get = ffDataOut$D_OUT ;
  assign RDY_dataOut_get = ffDataOut$EMPTY_N ;
  assign CAN_FIRE_dataOut_get = ffDataOut$EMPTY_N ;
  assign WILL_FIRE_dataOut_get = EN_dataOut_get ;

  // submodule ffB2C
  FIFO2 #(.width(32'd4), .guarded(32'd1)) ffB2C(.RST(RST_N),
						.CLK(CLK),
						.D_IN(ffB2C$D_IN),
						.ENQ(ffB2C$ENQ),
						.DEQ(ffB2C$DEQ),
						.CLR(ffB2C$CLR),
						.D_OUT(ffB2C$D_OUT),
						.FULL_N(ffB2C$FULL_N),
						.EMPTY_N(ffB2C$EMPTY_N));

  // submodule ffCodeIn
  FIFO2 #(.width(32'd4), .guarded(32'd1)) ffCodeIn(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(ffCodeIn$D_IN),
						   .ENQ(ffCodeIn$ENQ),
						   .DEQ(ffCodeIn$DEQ),
						   .CLR(ffCodeIn$CLR),
						   .D_OUT(ffCodeIn$D_OUT),
						   .FULL_N(ffCodeIn$FULL_N),
						   .EMPTY_N(ffCodeIn$EMPTY_N));

  // submodule ffDataOut
  FIFO2 #(.width(32'd4), .guarded(32'd1)) ffDataOut(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(ffDataOut$D_IN),
						    .ENQ(ffDataOut$ENQ),
						    .DEQ(ffDataOut$DEQ),
						    .CLR(ffDataOut$CLR),
						    .D_OUT(ffDataOut$D_OUT),
						    .FULL_N(ffDataOut$FULL_N),
						    .EMPTY_N(ffDataOut$EMPTY_N));

  // submodule vffC2B_0
  FIFO2 #(.width(32'd4), .guarded(32'd1)) vffC2B_0(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffC2B_0$D_IN),
						   .ENQ(vffC2B_0$ENQ),
						   .DEQ(vffC2B_0$DEQ),
						   .CLR(vffC2B_0$CLR),
						   .D_OUT(vffC2B_0$D_OUT),
						   .FULL_N(vffC2B_0$FULL_N),
						   .EMPTY_N(vffC2B_0$EMPTY_N));

  // submodule vffC2B_1
  FIFO2 #(.width(32'd4), .guarded(32'd1)) vffC2B_1(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffC2B_1$D_IN),
						   .ENQ(vffC2B_1$ENQ),
						   .DEQ(vffC2B_1$DEQ),
						   .CLR(vffC2B_1$CLR),
						   .D_OUT(vffC2B_1$D_OUT),
						   .FULL_N(vffC2B_1$FULL_N),
						   .EMPTY_N(vffC2B_1$EMPTY_N));

  // submodule vffC2B_2
  FIFO2 #(.width(32'd4), .guarded(32'd1)) vffC2B_2(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffC2B_2$D_IN),
						   .ENQ(vffC2B_2$ENQ),
						   .DEQ(vffC2B_2$DEQ),
						   .CLR(vffC2B_2$CLR),
						   .D_OUT(vffC2B_2$D_OUT),
						   .FULL_N(vffC2B_2$FULL_N),
						   .EMPTY_N(vffC2B_2$EMPTY_N));

  // rule RL_rlProcessFirstIteration
  assign CAN_FIRE_RL_rlProcessFirstIteration =
	     ffCodeIn$EMPTY_N && ffB2C$FULL_N && rgIterationCount == 4'd0 ;
  assign WILL_FIRE_RL_rlProcessFirstIteration =
	     CAN_FIRE_RL_rlProcessFirstIteration ;

  // rule RL_rlProcessRemIteration
  assign CAN_FIRE_RL_rlProcessRemIteration =
	     vffC2B_0$EMPTY_N && vffC2B_1$EMPTY_N && vffC2B_2$EMPTY_N &&
	     ffDataOut$FULL_N &&
	     ffB2C$FULL_N &&
	     rgIterationCount != 4'd0 &&
	     rgIterationCount < 4'd8 ;
  assign WILL_FIRE_RL_rlProcessRemIteration =
	     CAN_FIRE_RL_rlProcessRemIteration ;

  // inputs to muxes for submodule ports
  assign MUX_ffB2C$enq_1__SEL_1 =
	     WILL_FIRE_RL_rlProcessRemIteration && rgIterationCount != 4'd7 ;
  module_fnBitNodeProcessing instance_fnBitNodeProcessing_0(.fnBitNodeProcessing_x({ vffC2B_2$D_OUT,
										     vffC2B_1$D_OUT,
										     vffC2B_0$D_OUT }),
							    .fnBitNodeProcessing(MUX_ffB2C$enq_1__VAL_1));
  assign MUX_rgIterationCount$write_1__VAL_1 = rgIterationCount + 4'd1 ;
  assign MUX_rgIterationCount$write_1__VAL_2 =
	     (rgIterationCount == 4'd7) ? 4'd0 : x__h1193 ;

  // register rgIterationCount
  assign rgIterationCount$D_IN =
	     WILL_FIRE_RL_rlProcessFirstIteration ?
	       MUX_rgIterationCount$write_1__VAL_1 :
	       MUX_rgIterationCount$write_1__VAL_2 ;
  assign rgIterationCount$EN =
	     WILL_FIRE_RL_rlProcessFirstIteration ||
	     WILL_FIRE_RL_rlProcessRemIteration ;

  // submodule ffB2C
  assign ffB2C$D_IN =
	     MUX_ffB2C$enq_1__SEL_1 ?
	       MUX_ffB2C$enq_1__VAL_1 :
	       ffCodeIn$D_OUT ;
  assign ffB2C$ENQ =
	     WILL_FIRE_RL_rlProcessRemIteration && rgIterationCount != 4'd7 ||
	     WILL_FIRE_RL_rlProcessFirstIteration ;
  assign ffB2C$DEQ = EN_b2c_get ;
  assign ffB2C$CLR = 1'b0 ;

  // submodule ffCodeIn
  assign ffCodeIn$D_IN = codeIn_put ;
  assign ffCodeIn$ENQ = EN_codeIn_put ;
  assign ffCodeIn$DEQ = CAN_FIRE_RL_rlProcessFirstIteration ;
  assign ffCodeIn$CLR = 1'b0 ;

  // submodule ffDataOut
  assign ffDataOut$D_IN = MUX_ffB2C$enq_1__VAL_1 ;
  assign ffDataOut$ENQ =
	     WILL_FIRE_RL_rlProcessRemIteration && rgIterationCount == 4'd7 ;
  assign ffDataOut$DEQ = EN_dataOut_get ;
  assign ffDataOut$CLR = 1'b0 ;

  // submodule vffC2B_0
  assign vffC2B_0$D_IN = c2b_0_put ;
  assign vffC2B_0$ENQ = EN_c2b_0_put ;
  assign vffC2B_0$DEQ = CAN_FIRE_RL_rlProcessRemIteration ;
  assign vffC2B_0$CLR = 1'b0 ;

  // submodule vffC2B_1
  assign vffC2B_1$D_IN = c2b_1_put ;
  assign vffC2B_1$ENQ = EN_c2b_1_put ;
  assign vffC2B_1$DEQ = CAN_FIRE_RL_rlProcessRemIteration ;
  assign vffC2B_1$CLR = 1'b0 ;

  // submodule vffC2B_2
  assign vffC2B_2$D_IN = c2b_2_put ;
  assign vffC2B_2$ENQ = EN_c2b_2_put ;
  assign vffC2B_2$DEQ = CAN_FIRE_RL_rlProcessRemIteration ;
  assign vffC2B_2$CLR = 1'b0 ;

  // remaining internal signals
  assign x__h1193 = rgIterationCount + 4'd2 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rgIterationCount <= `BSV_ASSIGNMENT_DELAY 4'd0;
      end
    else
      begin
        if (rgIterationCount$EN)
	  rgIterationCount <= `BSV_ASSIGNMENT_DELAY rgIterationCount$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rgIterationCount = 4'hA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkBitNode

