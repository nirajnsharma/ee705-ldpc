//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Sat Apr 27 11:34:04 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// RDY_c2b_0_put                  O     1 reg
// RDY_c2b_1_put                  O     1 reg
// RDY_c2b_2_put                  O     1 reg
// b2c_get                        O     1 reg
// RDY_b2c_get                    O     1 reg
// RDY_codeIn_put                 O     1 reg
// dataOut_get                    O     1 reg
// RDY_dataOut_get                O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// c2b_0_put                      I     1 reg
// c2b_1_put                      I     1 reg
// c2b_2_put                      I     1 reg
// codeIn_put                     I     1 reg
// EN_c2b_0_put                   I     1
// EN_c2b_1_put                   I     1
// EN_c2b_2_put                   I     1
// EN_codeIn_put                  I     1
// EN_b2c_get                     I     1
// EN_dataOut_get                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkBitNode(CLK,
		 RST_N,

		 c2b_0_put,
		 EN_c2b_0_put,
		 RDY_c2b_0_put,

		 c2b_1_put,
		 EN_c2b_1_put,
		 RDY_c2b_1_put,

		 c2b_2_put,
		 EN_c2b_2_put,
		 RDY_c2b_2_put,

		 EN_b2c_get,
		 b2c_get,
		 RDY_b2c_get,

		 codeIn_put,
		 EN_codeIn_put,
		 RDY_codeIn_put,

		 EN_dataOut_get,
		 dataOut_get,
		 RDY_dataOut_get);
  input  CLK;
  input  RST_N;

  // action method c2b_0_put
  input  c2b_0_put;
  input  EN_c2b_0_put;
  output RDY_c2b_0_put;

  // action method c2b_1_put
  input  c2b_1_put;
  input  EN_c2b_1_put;
  output RDY_c2b_1_put;

  // action method c2b_2_put
  input  c2b_2_put;
  input  EN_c2b_2_put;
  output RDY_c2b_2_put;

  // actionvalue method b2c_get
  input  EN_b2c_get;
  output b2c_get;
  output RDY_b2c_get;

  // action method codeIn_put
  input  codeIn_put;
  input  EN_codeIn_put;
  output RDY_codeIn_put;

  // actionvalue method dataOut_get
  input  EN_dataOut_get;
  output dataOut_get;
  output RDY_dataOut_get;

  // signals for module outputs
  wire RDY_b2c_get,
       RDY_c2b_0_put,
       RDY_c2b_1_put,
       RDY_c2b_2_put,
       RDY_codeIn_put,
       RDY_dataOut_get,
       b2c_get,
       dataOut_get;

  // ports of submodule ffB2C
  wire ffB2C$CLR,
       ffB2C$DEQ,
       ffB2C$D_IN,
       ffB2C$D_OUT,
       ffB2C$EMPTY_N,
       ffB2C$ENQ,
       ffB2C$FULL_N;

  // ports of submodule ffCodeIn
  wire ffCodeIn$CLR,
       ffCodeIn$DEQ,
       ffCodeIn$D_IN,
       ffCodeIn$D_OUT,
       ffCodeIn$EMPTY_N,
       ffCodeIn$ENQ,
       ffCodeIn$FULL_N;

  // ports of submodule ffDataOut
  wire ffDataOut$CLR,
       ffDataOut$DEQ,
       ffDataOut$D_IN,
       ffDataOut$D_OUT,
       ffDataOut$EMPTY_N,
       ffDataOut$ENQ,
       ffDataOut$FULL_N;

  // ports of submodule vffC2B_0
  wire vffC2B_0$CLR,
       vffC2B_0$DEQ,
       vffC2B_0$D_IN,
       vffC2B_0$D_OUT,
       vffC2B_0$EMPTY_N,
       vffC2B_0$ENQ,
       vffC2B_0$FULL_N;

  // ports of submodule vffC2B_1
  wire vffC2B_1$CLR,
       vffC2B_1$DEQ,
       vffC2B_1$D_IN,
       vffC2B_1$D_OUT,
       vffC2B_1$EMPTY_N,
       vffC2B_1$ENQ,
       vffC2B_1$FULL_N;

  // ports of submodule vffC2B_2
  wire vffC2B_2$CLR,
       vffC2B_2$DEQ,
       vffC2B_2$D_IN,
       vffC2B_2$D_OUT,
       vffC2B_2$EMPTY_N,
       vffC2B_2$ENQ,
       vffC2B_2$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rlProcessChkNodeResult,
       CAN_FIRE_RL_rlProcessNewData,
       CAN_FIRE___me_check_1,
       CAN_FIRE_b2c_get,
       CAN_FIRE_c2b_0_put,
       CAN_FIRE_c2b_1_put,
       CAN_FIRE_c2b_2_put,
       CAN_FIRE_codeIn_put,
       CAN_FIRE_dataOut_get,
       WILL_FIRE_RL_rlProcessChkNodeResult,
       WILL_FIRE_RL_rlProcessNewData,
       WILL_FIRE___me_check_1,
       WILL_FIRE_b2c_get,
       WILL_FIRE_c2b_0_put,
       WILL_FIRE_c2b_1_put,
       WILL_FIRE_c2b_2_put,
       WILL_FIRE_codeIn_put,
       WILL_FIRE_dataOut_get;

  // action method c2b_0_put
  assign RDY_c2b_0_put = vffC2B_0$FULL_N ;
  assign CAN_FIRE_c2b_0_put = vffC2B_0$FULL_N ;
  assign WILL_FIRE_c2b_0_put = EN_c2b_0_put ;

  // action method c2b_1_put
  assign RDY_c2b_1_put = vffC2B_1$FULL_N ;
  assign CAN_FIRE_c2b_1_put = vffC2B_1$FULL_N ;
  assign WILL_FIRE_c2b_1_put = EN_c2b_1_put ;

  // action method c2b_2_put
  assign RDY_c2b_2_put = vffC2B_2$FULL_N ;
  assign CAN_FIRE_c2b_2_put = vffC2B_2$FULL_N ;
  assign WILL_FIRE_c2b_2_put = EN_c2b_2_put ;

  // actionvalue method b2c_get
  assign b2c_get = ffB2C$D_OUT ;
  assign RDY_b2c_get = ffB2C$EMPTY_N ;
  assign CAN_FIRE_b2c_get = ffB2C$EMPTY_N ;
  assign WILL_FIRE_b2c_get = EN_b2c_get ;

  // action method codeIn_put
  assign RDY_codeIn_put = ffCodeIn$FULL_N ;
  assign CAN_FIRE_codeIn_put = ffCodeIn$FULL_N ;
  assign WILL_FIRE_codeIn_put = EN_codeIn_put ;

  // actionvalue method dataOut_get
  assign dataOut_get = ffDataOut$D_OUT ;
  assign RDY_dataOut_get = ffDataOut$EMPTY_N ;
  assign CAN_FIRE_dataOut_get = ffDataOut$EMPTY_N ;
  assign WILL_FIRE_dataOut_get = EN_dataOut_get ;

  // submodule ffB2C
  FIFO2 #(.width(32'd1), .guarded(32'd1)) ffB2C(.RST(RST_N),
						.CLK(CLK),
						.D_IN(ffB2C$D_IN),
						.ENQ(ffB2C$ENQ),
						.DEQ(ffB2C$DEQ),
						.CLR(ffB2C$CLR),
						.D_OUT(ffB2C$D_OUT),
						.FULL_N(ffB2C$FULL_N),
						.EMPTY_N(ffB2C$EMPTY_N));

  // submodule ffCodeIn
  FIFO2 #(.width(32'd1), .guarded(32'd1)) ffCodeIn(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(ffCodeIn$D_IN),
						   .ENQ(ffCodeIn$ENQ),
						   .DEQ(ffCodeIn$DEQ),
						   .CLR(ffCodeIn$CLR),
						   .D_OUT(ffCodeIn$D_OUT),
						   .FULL_N(ffCodeIn$FULL_N),
						   .EMPTY_N(ffCodeIn$EMPTY_N));

  // submodule ffDataOut
  FIFO2 #(.width(32'd1), .guarded(32'd1)) ffDataOut(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(ffDataOut$D_IN),
						    .ENQ(ffDataOut$ENQ),
						    .DEQ(ffDataOut$DEQ),
						    .CLR(ffDataOut$CLR),
						    .D_OUT(ffDataOut$D_OUT),
						    .FULL_N(ffDataOut$FULL_N),
						    .EMPTY_N(ffDataOut$EMPTY_N));

  // submodule vffC2B_0
  FIFO2 #(.width(32'd1), .guarded(32'd1)) vffC2B_0(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffC2B_0$D_IN),
						   .ENQ(vffC2B_0$ENQ),
						   .DEQ(vffC2B_0$DEQ),
						   .CLR(vffC2B_0$CLR),
						   .D_OUT(vffC2B_0$D_OUT),
						   .FULL_N(vffC2B_0$FULL_N),
						   .EMPTY_N(vffC2B_0$EMPTY_N));

  // submodule vffC2B_1
  FIFO2 #(.width(32'd1), .guarded(32'd1)) vffC2B_1(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffC2B_1$D_IN),
						   .ENQ(vffC2B_1$ENQ),
						   .DEQ(vffC2B_1$DEQ),
						   .CLR(vffC2B_1$CLR),
						   .D_OUT(vffC2B_1$D_OUT),
						   .FULL_N(vffC2B_1$FULL_N),
						   .EMPTY_N(vffC2B_1$EMPTY_N));

  // submodule vffC2B_2
  FIFO2 #(.width(32'd1), .guarded(32'd1)) vffC2B_2(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffC2B_2$D_IN),
						   .ENQ(vffC2B_2$ENQ),
						   .DEQ(vffC2B_2$DEQ),
						   .CLR(vffC2B_2$CLR),
						   .D_OUT(vffC2B_2$D_OUT),
						   .FULL_N(vffC2B_2$FULL_N),
						   .EMPTY_N(vffC2B_2$EMPTY_N));

  // rule RL_rlProcessNewData
  assign CAN_FIRE_RL_rlProcessNewData = ffCodeIn$EMPTY_N && ffB2C$FULL_N ;
  assign WILL_FIRE_RL_rlProcessNewData = CAN_FIRE_RL_rlProcessNewData ;

  // rule RL_rlProcessChkNodeResult
  assign CAN_FIRE_RL_rlProcessChkNodeResult =
	     vffC2B_0$EMPTY_N && vffC2B_1$EMPTY_N && vffC2B_2$EMPTY_N &&
	     ffDataOut$FULL_N ;
  assign WILL_FIRE_RL_rlProcessChkNodeResult =
	     CAN_FIRE_RL_rlProcessChkNodeResult ;

  // rule __me_check_1
  assign CAN_FIRE___me_check_1 = 1'b1 ;
  assign WILL_FIRE___me_check_1 = 1'b1 ;

  // submodule ffB2C
  assign ffB2C$D_IN = ffCodeIn$D_OUT ;
  assign ffB2C$ENQ = CAN_FIRE_RL_rlProcessNewData ;
  assign ffB2C$DEQ = EN_b2c_get ;
  assign ffB2C$CLR = 1'b0 ;

  // submodule ffCodeIn
  assign ffCodeIn$D_IN = codeIn_put ;
  assign ffCodeIn$ENQ = EN_codeIn_put ;
  assign ffCodeIn$DEQ = CAN_FIRE_RL_rlProcessNewData ;
  assign ffCodeIn$CLR = 1'b0 ;

  // submodule ffDataOut
  module_fnBitNodeCore instance_fnBitNodeCore_0(.fnBitNodeCore_i({ vffC2B_2$D_OUT,
								   vffC2B_1$D_OUT,
								   vffC2B_0$D_OUT }),
						.fnBitNodeCore(ffDataOut$D_IN));
  assign ffDataOut$ENQ = CAN_FIRE_RL_rlProcessChkNodeResult ;
  assign ffDataOut$DEQ = EN_dataOut_get ;
  assign ffDataOut$CLR = 1'b0 ;

  // submodule vffC2B_0
  assign vffC2B_0$D_IN = c2b_0_put ;
  assign vffC2B_0$ENQ = EN_c2b_0_put ;
  assign vffC2B_0$DEQ = CAN_FIRE_RL_rlProcessChkNodeResult ;
  assign vffC2B_0$CLR = 1'b0 ;

  // submodule vffC2B_1
  assign vffC2B_1$D_IN = c2b_1_put ;
  assign vffC2B_1$ENQ = EN_c2b_1_put ;
  assign vffC2B_1$DEQ = CAN_FIRE_RL_rlProcessChkNodeResult ;
  assign vffC2B_1$CLR = 1'b0 ;

  // submodule vffC2B_2
  assign vffC2B_2$D_IN = c2b_2_put ;
  assign vffC2B_2$ENQ = EN_c2b_2_put ;
  assign vffC2B_2$DEQ = CAN_FIRE_RL_rlProcessChkNodeResult ;
  assign vffC2B_2$CLR = 1'b0 ;

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rlProcessChkNodeResult &&
	  WILL_FIRE_RL_rlProcessNewData)
	$display("Error: \"Nodes.bsv\", line 90, column 29: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_rlProcessChkNodeResult] and\n  [RL_rlProcessNewData] ) fired in the same clock cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkBitNode

