//
// Generated by Bluespec Compiler, version 2018.10.beta1 (build e1df8052c, 2018-10-17)
//
// On Tue Apr 16 14:00:56 IST 2019
//
//
// Ports:
// Name                         I/O  size props
// RDY_b2c_0_put                  O     1 reg
// RDY_b2c_1_put                  O     1 reg
// RDY_b2c_2_put                  O     1 reg
// c2b_get                        O     4 reg
// RDY_c2b_get                    O     1 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// b2c_0_put                      I     4 reg
// b2c_1_put                      I     4 reg
// b2c_2_put                      I     4 reg
// EN_b2c_0_put                   I     1
// EN_b2c_1_put                   I     1
// EN_b2c_2_put                   I     1
// EN_c2b_get                     I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCheckNode(CLK,
		   RST_N,

		   b2c_0_put,
		   EN_b2c_0_put,
		   RDY_b2c_0_put,

		   b2c_1_put,
		   EN_b2c_1_put,
		   RDY_b2c_1_put,

		   b2c_2_put,
		   EN_b2c_2_put,
		   RDY_b2c_2_put,

		   EN_c2b_get,
		   c2b_get,
		   RDY_c2b_get);
  input  CLK;
  input  RST_N;

  // action method b2c_0_put
  input  [3 : 0] b2c_0_put;
  input  EN_b2c_0_put;
  output RDY_b2c_0_put;

  // action method b2c_1_put
  input  [3 : 0] b2c_1_put;
  input  EN_b2c_1_put;
  output RDY_b2c_1_put;

  // action method b2c_2_put
  input  [3 : 0] b2c_2_put;
  input  EN_b2c_2_put;
  output RDY_b2c_2_put;

  // actionvalue method c2b_get
  input  EN_c2b_get;
  output [3 : 0] c2b_get;
  output RDY_c2b_get;

  // signals for module outputs
  wire [3 : 0] c2b_get;
  wire RDY_b2c_0_put, RDY_b2c_1_put, RDY_b2c_2_put, RDY_c2b_get;

  // ports of submodule ffC2B
  wire [3 : 0] ffC2B$D_IN, ffC2B$D_OUT;
  wire ffC2B$CLR, ffC2B$DEQ, ffC2B$EMPTY_N, ffC2B$ENQ, ffC2B$FULL_N;

  // ports of submodule vffB2C_0
  wire [3 : 0] vffB2C_0$D_IN, vffB2C_0$D_OUT;
  wire vffB2C_0$CLR,
       vffB2C_0$DEQ,
       vffB2C_0$EMPTY_N,
       vffB2C_0$ENQ,
       vffB2C_0$FULL_N;

  // ports of submodule vffB2C_1
  wire [3 : 0] vffB2C_1$D_IN, vffB2C_1$D_OUT;
  wire vffB2C_1$CLR,
       vffB2C_1$DEQ,
       vffB2C_1$EMPTY_N,
       vffB2C_1$ENQ,
       vffB2C_1$FULL_N;

  // ports of submodule vffB2C_2
  wire [3 : 0] vffB2C_2$D_IN, vffB2C_2$D_OUT;
  wire vffB2C_2$CLR,
       vffB2C_2$DEQ,
       vffB2C_2$EMPTY_N,
       vffB2C_2$ENQ,
       vffB2C_2$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_rlProcessIteration,
       CAN_FIRE_b2c_0_put,
       CAN_FIRE_b2c_1_put,
       CAN_FIRE_b2c_2_put,
       CAN_FIRE_c2b_get,
       WILL_FIRE_RL_rlProcessIteration,
       WILL_FIRE_b2c_0_put,
       WILL_FIRE_b2c_1_put,
       WILL_FIRE_b2c_2_put,
       WILL_FIRE_c2b_get;

  // action method b2c_0_put
  assign RDY_b2c_0_put = vffB2C_0$FULL_N ;
  assign CAN_FIRE_b2c_0_put = vffB2C_0$FULL_N ;
  assign WILL_FIRE_b2c_0_put = EN_b2c_0_put ;

  // action method b2c_1_put
  assign RDY_b2c_1_put = vffB2C_1$FULL_N ;
  assign CAN_FIRE_b2c_1_put = vffB2C_1$FULL_N ;
  assign WILL_FIRE_b2c_1_put = EN_b2c_1_put ;

  // action method b2c_2_put
  assign RDY_b2c_2_put = vffB2C_2$FULL_N ;
  assign CAN_FIRE_b2c_2_put = vffB2C_2$FULL_N ;
  assign WILL_FIRE_b2c_2_put = EN_b2c_2_put ;

  // actionvalue method c2b_get
  assign c2b_get = ffC2B$D_OUT ;
  assign RDY_c2b_get = ffC2B$EMPTY_N ;
  assign CAN_FIRE_c2b_get = ffC2B$EMPTY_N ;
  assign WILL_FIRE_c2b_get = EN_c2b_get ;

  // submodule ffC2B
  FIFO2 #(.width(32'd4), .guarded(32'd1)) ffC2B(.RST(RST_N),
						.CLK(CLK),
						.D_IN(ffC2B$D_IN),
						.ENQ(ffC2B$ENQ),
						.DEQ(ffC2B$DEQ),
						.CLR(ffC2B$CLR),
						.D_OUT(ffC2B$D_OUT),
						.FULL_N(ffC2B$FULL_N),
						.EMPTY_N(ffC2B$EMPTY_N));

  // submodule vffB2C_0
  FIFO2 #(.width(32'd4), .guarded(32'd1)) vffB2C_0(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffB2C_0$D_IN),
						   .ENQ(vffB2C_0$ENQ),
						   .DEQ(vffB2C_0$DEQ),
						   .CLR(vffB2C_0$CLR),
						   .D_OUT(vffB2C_0$D_OUT),
						   .FULL_N(vffB2C_0$FULL_N),
						   .EMPTY_N(vffB2C_0$EMPTY_N));

  // submodule vffB2C_1
  FIFO2 #(.width(32'd4), .guarded(32'd1)) vffB2C_1(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffB2C_1$D_IN),
						   .ENQ(vffB2C_1$ENQ),
						   .DEQ(vffB2C_1$DEQ),
						   .CLR(vffB2C_1$CLR),
						   .D_OUT(vffB2C_1$D_OUT),
						   .FULL_N(vffB2C_1$FULL_N),
						   .EMPTY_N(vffB2C_1$EMPTY_N));

  // submodule vffB2C_2
  FIFO2 #(.width(32'd4), .guarded(32'd1)) vffB2C_2(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(vffB2C_2$D_IN),
						   .ENQ(vffB2C_2$ENQ),
						   .DEQ(vffB2C_2$DEQ),
						   .CLR(vffB2C_2$CLR),
						   .D_OUT(vffB2C_2$D_OUT),
						   .FULL_N(vffB2C_2$FULL_N),
						   .EMPTY_N(vffB2C_2$EMPTY_N));

  // rule RL_rlProcessIteration
  assign CAN_FIRE_RL_rlProcessIteration =
	     vffB2C_0$EMPTY_N && vffB2C_1$EMPTY_N && vffB2C_2$EMPTY_N &&
	     ffC2B$FULL_N ;
  assign WILL_FIRE_RL_rlProcessIteration = CAN_FIRE_RL_rlProcessIteration ;

  // submodule ffC2B
  module_fnCheckNodeProcessing instance_fnCheckNodeProcessing_0(.fnCheckNodeProcessing_x({ vffB2C_2$D_OUT,
											   vffB2C_1$D_OUT,
											   vffB2C_0$D_OUT }),
								.fnCheckNodeProcessing(ffC2B$D_IN));
  assign ffC2B$ENQ = CAN_FIRE_RL_rlProcessIteration ;
  assign ffC2B$DEQ = EN_c2b_get ;
  assign ffC2B$CLR = 1'b0 ;

  // submodule vffB2C_0
  assign vffB2C_0$D_IN = b2c_0_put ;
  assign vffB2C_0$ENQ = EN_b2c_0_put ;
  assign vffB2C_0$DEQ = CAN_FIRE_RL_rlProcessIteration ;
  assign vffB2C_0$CLR = 1'b0 ;

  // submodule vffB2C_1
  assign vffB2C_1$D_IN = b2c_1_put ;
  assign vffB2C_1$ENQ = EN_b2c_1_put ;
  assign vffB2C_1$DEQ = CAN_FIRE_RL_rlProcessIteration ;
  assign vffB2C_1$CLR = 1'b0 ;

  // submodule vffB2C_2
  assign vffB2C_2$D_IN = b2c_2_put ;
  assign vffB2C_2$ENQ = EN_b2c_2_put ;
  assign vffB2C_2$DEQ = CAN_FIRE_RL_rlProcessIteration ;
  assign vffB2C_2$CLR = 1'b0 ;
endmodule  // mkCheckNode

